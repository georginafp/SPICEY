---
title: "Measuring tissue specificity from single cell data with SPICEY"
author: "Georgina Fuentes-Páez"
output: 
  BiocStyle::html_document:
    fig_width: 7
    fig_height: 5
vignette: >
  %\VignetteIndexEntry{Measuring tissue specificity from single cell data with SPICEY}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}

library(dplyr)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(SPICEY)

knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    eval = TRUE,
    warning = FALSE,
    message = FALSE,
    fig.align = "center",
    out.width = "80%"
)

```

```{r logo, echo=FALSE, eval=TRUE, out.width='10%'}
knitr::include_graphics("../man/figures/logo_spicey.png", dpi = 800)
```

# Introduction

SPICEY is an R package for quantifying cell-type specificity from single-cell omics data. It supports inputs from common analysis frameworks such as `Seurat` (for single-cell RNA-seq) and `Signac` (for single-cell ATAC-seq), and provides a unified interface for computing cell-type-specificity metrics at both the regulatory and transcriptional levels.

## Preamble

SPICEY is designed to work with the results of differential analyses performed on single-cell ATAC-seq (to assess chromatin accessibility) or single-cell RNA-seq (to measure gene expression). These analyses typically compare features—either regulatory elements (e.g., peaks) or genes—across cell types to identify cell-type-specific activity or expression.

Rather than performing differential testing itself, SPICEY leverages pre-computed statistics from such analyses, specifically the **log2 fold-change** and associated **adjusted p-values**, which reflect both the magnitude and significance of cell-type enrichment. Using these inputs, SPICEY computes composite specificity scores that capture both the intensity and selectivity of differential signal across cell types.

In this tutorial, we illustrate the application of SPICEY on single-cell datasets derived from non-diabetic human pancreatic islets obtained through the Human Pancreas Analysis Program (HPAP) @ref. We analyzed paired single-nucleus ATAC-seq and RNA-seq data from three donors with similar total cell counts and comparable distributions of major pancreatic islet cell types. To associate distal regulatory elements with their putative target genes, we used co-accessibility links inferred via the `Cicero` package.

Differential expression and accessibility analyses were conducted using `Seurat` (`FindMarkers()`) function on both RNA and ATAC assays. All genes and regions were considered (`logfc.threshold = 0`), and the **Wilcoxon Rank Sum test** was used (`test.use = "wilcox"`), following `Seurat` default parameters.

## Cell-Type Specificity Indices: RETSI and GETSI

SPICEY defines two complementary metrics to quantify cell-type specificity:

-   **RETSI** (Regulatory Element Tissue Specificity Index): Evaluates the specificity of regulatory elements (e.g., ATAC-seq peaks) across different cell types.
-   **GETSI** (Gene Expression Tissue Specificity Index): Evaluates the specificity of gene expression patterns across cell types.

Both RETSI and GETSI are calculated using a weighted specificity score for each feature (regulatory region or gene), reflecting the level of enrichment in each cell type. These specificity indices are computed as follows:

$$
TSI_{i,x} = \frac{FC_{i,x}}{\max(FC)_x} \cdot w_{i,x}
$$

$$
w_{i,x} = \text{rescale}\left( -\log_{10}(padj_{i,x}),\ [0, 1] \right)
$$

where:

-   $i$ is a specific cell type
-   $x \in \{r, g\}$, with $r$ for regulatory region (RETSI) and $g$ for gene (GETSI)
-   $\text{FC}_{i,x}$ is the log fold-change of feature $x$ in cell type $i$
-   $w_{i,x}$ is the weight term, defined as the rescaled value of $-\log_{10}(\text{adjusted } p\text{-value})$ between 0 and 1

SPICEY offers two strategies for linking regulatory elements to their putative target genes:

1.  **Nearest-gene assignment:** based on proximity to the closest transcription start site (TSS).
2.  **Co-accessibility-based linking:** leveraging correlations in chromatin accessibility (e.g., via Cicero).

These linking methods enable the integration of regulatory specificity (RETSI) and gene expression specificity (GETSI), facilitating the construction of detailed cell-type-specific regulatory networks from single-cell data.

**Note:** This vignette illustrates the use of SPICEY with preprocessed `GRanges` inputs, which must be prepared externally as they are **not** provided within the package.

## Entropy-based Specificity Indices

Beyond fold change–based metrics, SPICEY employs an entropy-based approach to measure the distributional skewness of feature activity across cell types using **Shannon entropy**.

For each feature, activity or expression values are normalized into a probability distribution representing signal concentration across all $N$ cell types. Lower entropy values indicate stronger cell-type specificity, whereas higher entropy suggests more uniform distribution. These entropy-based specificity indices are calculated as follows:

$$
H = - \sum_{i=1}^{N} p_i \log_2(p_i)
$$

$$
H_{norm} = 1 - e^{H}
$$

where:

-   $p_{i,x} = \frac{a_{i,x}}{\sum_{j=1}^{N} a_{j,x}}$ is the normalized activity or expression of feature $x$ across $N$ cell types
-   $a_{i,x}$ is the activity (for RETSI) or expression (for GETSI) value in cell type \$\$
-   $H_x$ is the Shannon entropy, and Normalized Entropy ranges between 0 (cell type specific) and 1 (cell type shared).

# Installation

Install the development version from GitHub:

```{r install, eval=FALSE, echo=TRUE}
install.packages("devtools")
devtools::install_github("georginafp/SPICEY")
```

# Input Requirements

SPICEY requires preprocessed input files generated from differential analyses of single-cell omics data, specifically chromatin accessibility (ATAC-seq) and/or gene expression (RNA-seq). These inputs are **not included** in the package and must be prepared externally. Below is a detailed overview of the required input formats and metadata.

## Single-cell ATAC-seq Data

-   **Accepted Formats:**

    -   A **named list** of `GRanges` objects or `data.frame`s (convertible to `GRanges`), where each element contains differential accessibility results for a specific cell type.\
    -   A `GRangesList` with each element representing a distinct cell type.

    All inputs must be **named** with cell type identifiers.

-   **Required Columns (per element):**

    -   `region_id` — Unique peak identifier matching the format in your ATAC data (e.g., `chr1-5000-5800` or `chr1:5000-5800`).
    -   `avg_log2FC` — Average log2 fold-change of accessibility in the given cell type.
    -   `p_val_adj` — Adjusted p-value from the differential test.
    -   `cell_type` — Cell type or cluster label for each measurement.

Each peak should have multiple entries, one per cell type, allowing SPICEY to assess cell-type-specific accessibility patterns.

```{r da-atac, message=FALSE, warning=FALSE}
data("atac")
```

## Single-cell RNA-seq Data

-   **Accepted Formats:**

    -   A **named list** of `GRanges` objects or `data.frame`s (convertible to `GRanges`), with each element containing differential expression results for a specific cell type.\
    -   A `GRangesList`, where each element corresponds to a distinct cell type.

    The list or `GRangesList` must be **named** with cell type identifiers.

-   **Required Columns (per element):**

    -   `gene_id` — Gene identifier column, consistent across all entries, using *official gene symbols* (e.g., `GAPDH`).
    -   `avg_log2FC` — Average log2 fold-change in expression for the gene within the specific cell type.
    -   `p_val_adj` — Adjusted p-value from the differential test.
    -   `cell_type` — Cell type or cluster label associated with the measurement.

Each gene should have multiple entries—one per cell type—enabling SPICEY to evaluate expression specificity across cell populations.

```{r da-rna, message=FALSE, warning=FALSE}
data("rna")
```

## Co-accessibility Links (Optional for Region-to-Gene Linking)

-   **Purpose:**\
    Link regulatory elements to putative target genes based on co-accessibility, typically derived from tools like `Cicero`. This input is required only when using the `annotation` parameter for RETSI/GETSI integration.

-   **Format:**\
    A `data.frame` containing co-accessibility pairs and their scores.

-   **Required Columns:**

    -   `Peaks1` — Genomic coordinate or ID of the first peak in the pair.
    -   `Peaks2` — Genomic coordinate or ID of the second peak.
    -   `coaccess` — Co-accessibility score or correlation value between the paired peaks.

**Note:** Peak identifiers in `Peaks1` and `Peaks2` must exactly match those in the ATAC input, including coordinate formatting (e.g., `chr1:5000-6000` vs. `chr1-5000-6000`). Inconsistent formats will disrupt accurate annotation.

```{r links, message=FALSE, warning=FALSE}
data("cicero_links")
head(cicero_links)
```

# Example: Step-by-Step SPICEY Workflow

This section outlines how to execute SPICEY using preprocessed input files, as detailed previously.

## Computing RETSI

To calculate the **Regulatory Element Tissue Specificity Index (RETSI)**, the following inputs are required:

-   **`atac`**: A named list of `GRanges` objects or `data.frame`s (convertible to `GRanges`), each representing differential accessibility results for a distinct cell type.
-   **`region_id`**: A character string specifying the column name containing region identifiers (e.g., `chr1-5000-5800`).

SPICEY returns a `data.frame` combining the input differential accessibility data with RETSI scores for each regulatory region.

**Note:** Confirm that your inputs comply with the format outlined in the *Input Requirements* section prior to execution.

```{r retsi, message=FALSE, warning=FALSE}
retsi <- SPICEY(atac=atac, region_id = "region_id")
head(retsi)
```

---
title: "HPAP CTRL SPICEY"
author: "Georgina Fuentes"
date: "2025-05-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.algn = "center",
                      warning = FALSE,
                      message = FALSE,
                      fig.width=5, 
                      fig.height=5)

## packages
library(GenomicRanges)
library(dplyr)
library(ggplot2)
library(Seurat)
library(tidyr)
library(regioneR)
library(purrr)
library(Signac)
library(purrr)
library(ggside)
library(viridis)
library(tibble)
library(ggsignif)
library(RColorBrewer)
library(ggplotify)
library(pheatmap)
library(patchwork)
library(scales)
library(data.table)
library(here)
library(S4Vectors)
library(ggpubr)
library(ggridges)
library(scales) 
library(tidyverse)
library(org.Hs.eg.db)
library(GenomicFeatures)

## spicey data 
# SPICEY_ANNOTATED_COACC <- readRDS("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/data/HPAP_CTRL_SPICEY_COACC.rds")
# hpap <- readRDS("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/data/SUBSET_CTRL_HPAP.rds")

## markers 
# hkg <- fgsea::gmtPathways("/homes/users/gfuentes/scratch/projects/spicey_paper/data/HOUNKPE_HOUSEKEEPING_GENES.v2024.1.Hs.gmt")
# ubiquitous <- hkg$HOUNKPE_HOUSEKEEPING_GENES
hkg <- fgsea::gmtPathways("/homes/users/gfuentes/scratch/projects/spicey_paper/data/HSIAO_HOUSEKEEPING_GENES.v2024.1.Hs.gmt")
ubiquitous <- hkg$HSIAO_HOUSEKEEPING_GENES


# ct_markers <- read.delim("/homes/users/gfuentes/shared_data/refs/hi_populations_markers.txt",
#                          stringsAsFactors=F)

url <- "https://docs.google.com/spreadsheets/d/1bdGW69IXu4Iy9Uinnfjd42xDtR6dkCOmX0B-T0qVxrI/edit?gid=0#gid=0"

get_gsheet <- function(url, sheet) {
  googlesheets4::gs4_deauth()
  googlesheets4::gs4_auth()
  gsheet <- googlesheets4::read_sheet(url, sheet)
  return(gsheet)
}
ct_markers <- get_gsheet(url=url, sheet="LP")
ct_markers <- ct_markers %>%
  data.frame() %>% 
  # mutate(CellType = gsub(" cells", "", CellType),
  #        CellType = gsub("Pancreatic stellate", "Stellate", CellType)) %>%
  # filter(Specie %in% c("Hs", "Mm Hs")) %>%
  # dplyr::select(-c(Specie)) %>%
  dplyr::filter(CellType %in% unique(SPICEY_ANNOTATED_COACC$linked$cell_type))
  


# ct_markers2 <- data.table::fread("/homes/users/gfuentes/shared_data/refs/Islet_important_Motifs.csv")
# ct_markers3 <- data.table::fread("/homes/users/gfuentes/shared_data/refs/PANCREATIC_BETA_GENES_HGNC.txt")
# ct_markers4 <- data.table::fread("/homes/users/gfuentes/shared_data/refs/Pasquali2014_SuppTable2_importantIsletGenes.csv")

# ct_markers <- unique(c(ct_markers$Gene, 
#                        ct_markers3$Symbol, 
#                        ct_markers4$Symbol
#                        ))



## disease 
# disease_paths <- list(
#   T1D = "/homes/users/gfuentes/shared_data/refs/T1D_GWAS_ASSOCIATIONS.tsv",
#   T2D = "/homes/users/gfuentes/shared_data/refs/T2D_GWAS_ASSOCIATIONS.tsv",
#   # LUNG_CANCER = "/homes/users/gfuentes/shared_data/refs/LUNG_CANCER_ASSOCIATIONS.tsv",
#   SCHIZO = "/homes/users/gfuentes/shared_data/refs/SCHIZOFRENIA_ASSOCIATIONS.tsv",
#   RHEUMATOID = "/homes/users/gfuentes/shared_data/refs/RHEUMATOID_ASSOCIATIONS.tsv",
#   PSORIASIS = "/homes/users/gfuentes/shared_data/refs/PSORIASIS_ASSOCIATIONS.tsv"
# )

## palette 
cell_colors <- c("Alpha" = "#008E80",
                 "Ductal" = "#5A7A98",
                 "Beta" = "#D37972",
                 "Delta" = "#fcbbb6",
                 "Acinar" = "#B4609B",
                 "Gamma" = "#C6E6FF",
                 "Stellate" = "#fbb679",
                 #"Quiescent-stellate" = "#ffdd6c",
                 "Unknown" = "#c7c7c7",
                 "Immune" = "#7E9F66",
                 "Epsilon" = "#A3D2CA",
                 "Endothelial" = "#87abbf")

```

```{r run-spicey, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

library(SPICEY)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)

atac <- readRDS("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/data/DA_ATAC_HPAP-CTRL.rds")
atac <- setNames(
  lapply(atac, function(x) {
    x <- as.data.frame(x)
    x$region_id <- paste0(x$seqnames, "-", x$start, "-", x$end)
    GenomicRanges::makeGRangesFromDataFrame(x, keep.extra.columns = TRUE)
  }),
  vapply(atac, function(x) unique(as.character(mcols(x)$cell_type)), character(1))
)


rna <- readRDS("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/data/DA_RNA_HPAP-CTRL.rds")
rna <- lapply(rna, function(df) { rownames_to_column(df, var = "gene_id")})

links <- readRDS("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/data/CTRL_LINKS_2.rds") %>%
  dplyr::filter(coaccess > 0.5)

peaks <- unlist(GRangesList(atac))
names(peaks) <- NULL

annotation_near <- annotate_with_nearest(peaks = peaks,
                                         txdb = TxDb.Hsapiens.UCSC.hg38.knownGene,
                                         annot_dbi = org.Hs.eg.db,
                                         protein_coding_only = TRUE,
                                         verbose = TRUE,
                                         add_tss_annotation = FALSE,
                                         upstream = 2000,
                                         downstream = 2000)

annotation_coacc <- annotate_with_coaccessibility(peaks = annotation_near |> 
                                                    dplyr::rename(nearestGeneSymbol = gene_id) |> 
                                                    makeGRangesFromDataFrame(keep.extra.columns = T),
                                                  txdb = TxDb.Hsapiens.UCSC.hg38.knownGene,
                                                  links_df=links,
                                                  annot_dbi = org.Hs.eg.db,
                                                  protein_coding_only = TRUE,
                                                  verbose = TRUE,
                                                  add_tss_annotation = TRUE,
                                                  upstream = 2000,
                                                  downstream = 2000)

SPICEY_ANNOTATED_COACC <- SPICEY(atac=atac, 
                                 region_id = "region_id", 
                                 rna=rna, 
                                 gene_id = "gene_id", 
                                 annotation = annotation_coacc)

saveRDS(SPICEY_ANNOTATED_COACC, "/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/data/HPAP_CTRL_SPICEY_COACC.rds")

```

```{r umap fig.show='hold', out.width='5%', message=FALSE, warning=FALSE, fig.width=5, fig.height=5}

knitr::include_graphics("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs/HPAP_CTRL_UMAP.png")

```

# Distribution of SPICEY measures

```{r distrib-spicey, message=FALSE, warning=FALSE, fig.width=6, fig.height=6}

# Prepare long data for SPICEY metrics
spicey_long <- SPICEY_ANNOTATED_COACC$linked %>%
  as.data.frame() %>%
  group_by(gene_id) %>%
  # filter(!(all(RETSI == 0 | is.na(RETSI)) & all(GETSI == 0 | is.na(GETSI)))) %>%
  ungroup() %>%
  pivot_longer(cols = c(RETSI, GETSI), names_to = "metric", values_to = "value") %>%
  filter(!is.na(value))


# Compute combined mean (RETSI + GETSI) for ordering
cell_order <- spicey_long %>%
  group_by(cell_type) %>%
  summarise(mean_value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mean_value)) %>%
  pull(cell_type)

# Reorder factor levels
spicey_long <- spicey_long %>%
  mutate(cell_type = factor(cell_type, levels = cell_order))

# Combine and summarize
.markers <- bind_rows(
  SPICEY_ANNOTATED_COACC$linked %>%
  data.frame() %>%
  inner_join(ct_markers %>% dplyr::select(-Source),
             by = c("gene_id" = "Gene", "cell_type" = "CellType")) %>%
  # filter(TSS_gene %in% ct_markers$Gene) %>%
  mutate(type = "Tissue-specific"), 

  SPICEY_ANNOTATED_COACC$linked %>%
  data.frame() %>%
  filter(gene_id %in% ubiquitous) %>%
  mutate(type = "Ubiquitous")
  ) %>%
  mutate(
    type = factor(type, levels = c("Ubiquitous", "Tissue-specific")),
    RETSI = as.numeric(RETSI),
    GETSI = as.numeric(GETSI)
  ) %>%
  filter(!is.na(RETSI), !is.na(GETSI)) %>%
  group_by(cell_type, type) %>%
  summarise(
    RETSI = mean(RETSI, na.rm = TRUE),
    GETSI = mean(GETSI, na.rm = TRUE),
    .groups = "drop"
  )




# Count number of cells per cell type (based on hpap annotation)
# cell_counts <- hpap@meta.data %>%
#   data.frame() %>%
#   count(cell_type = RNA_scSorter.Pred_Type.predicted.id) %>%
#   dplyr::filter(cell_type %in% cell_order) %>%
#   mutate(cell_type = factor(cell_type, levels = cell_order))

# Plot 1: Boxplot + jitter + marker dots
distribution <- ggplot(spicey_long, aes(x = cell_type, y = value)) +
  geom_jitter(color = "grey80", width = 0.15, size = 0.4, alpha = 0.05) +
  geom_boxplot(aes(fill = cell_type), position = position_dodge(width = 0.8),
               outlier.shape = NA, linewidth = 0.6, color = "gray45") +
  geom_point(
    data = .markers %>%
      pivot_longer(cols = c(RETSI, GETSI), names_to = "metric", values_to = "value"),
    aes(x = cell_type, y = value, color = type),
    size = 2
  ) +
  scale_color_manual(values = c(
  "Tissue-specific" = "#965819",
  "Ubiquitous" = "#585800"
)) +
  facet_grid(~metric) +
  scale_fill_manual(values = cell_colors) +
  labs(x = "Cell type", y = "SPICEY measure") +
  coord_flip() +
  theme_gray(base_size = 14) +
  theme(
    legend.position = "none",
    panel.grid.minor = element_blank(),
    axis.title = element_text(size = 10, margin = margin(t = 5)),
    axis.text = element_text(size = 8, margin = margin(t = 2)),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(size = 8),
    plot.title = element_text(size = 12),
    plot.margin = margin(5, 2, 5, 5)
  )

# Plot 2: Barplot of cell counts
# barplot_counts <- ggplot(cell_counts, aes(x = cell_type, y = n, fill = cell_type)) +
#   geom_col(width = 0.6) +
#   scale_fill_manual(values = cell_colors) +
#   coord_flip() +
#   labs(x = NULL, y = "# cells") +
#   theme_gray(base_size = 14) +
#   theme(
#     axis.text.y = element_blank(),  # ← hides y labels
#     axis.ticks.y = element_blank(),
#     axis.title.x = element_text(size = 10),
#     legend.position = "none",
#     panel.grid.minor = element_blank(),
#     axis.title = element_text(size = 10, margin = margin(t = 5)),
#     axis.text = element_text(size = 8, margin = margin(t = 2)),
#     axis.text.x = element_text(angle = 45, hjust = 1),
#     strip.text = element_text(size = 8),
#     plot.title = element_text(size = 12),
#     plot.margin = margin(5, 5, 5, 2)  # top, right, bottom, left
#   )

# # Combine plots side by side
# distribution_counts <- distribution + barplot_counts +
#   plot_layout(ncol = 2, widths = c(2, 0.5))

# distribution

distribution <- cowplot::plot_grid(distribution,                                  
                                   labels = c("A"), 
                                   label_size = 12)
distribution

ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/SPICEY_distribution.png"),
       plot = distribution, width = 5, height = 3.5, units = "in", dpi = 300)

```

# Distribution markers

```{r markers-tss, message=FALSE, warning=FALSE}

prom <- bind_rows(
  # Tissue-specific
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    inner_join(ct_markers %>% dplyr::select(-Source),
               by = c("gene_id" = "Gene", "cell_type" = "CellType")) %>%
    mutate(type = "Tissue-specific"),
  
  # Ubiquitous
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    filter(gene_id %in% ubiquitous) %>%
    mutate(type = "Ubiquitous")
) %>%
  mutate(
    type = factor(type, levels = c("Ubiquitous", "Tissue-specific")),
    RETSI = as.numeric(RETSI),
    GETSI = as.numeric(GETSI)
  ) %>%
  filter(!is.na(RETSI), !is.na(GETSI), !is.na(type)) %>%
  pivot_longer(cols = c(RETSI, GETSI),
               names_to = "spicey_measure",
               values_to = "value") %>%
  # Apply conditional TSS filters *only for RETSI*
  filter(
    spicey_measure != "RETSI" |
      (type == "Tissue-specific" & TSS_gene %in% ct_markers$Gene & annotation == "Promoter" |
      (type == "Ubiquitous" & TSS_gene %in% ubiquitous & annotation == "Promoter")
  )) %>%
  mutate(
    color_key = paste(type, spicey_measure, sep = "_")
  ) %>%
  ggplot(aes(x = value, color = color_key, fill = color_key)) +
  geom_density(alpha = 0.6) +
  ggside::geom_xsideboxplot(aes(y = spicey_measure, fill = color_key), 
                            orientation = "y", outlier.size = 0.1, 
                            outlier.alpha = 0.5) +
  ggside::scale_xsidey_discrete() +
  scale_y_continuous(name = "Density") +
  scale_color_manual(values = c(
    "Ubiquitous_RETSI" = "#656d4a",
    "Ubiquitous_GETSI" = "#5e614b",
    "Tissue-specific_RETSI" = "#b37a56",
    "Tissue-specific_GETSI" = "#8c5e3c"
  )) +
  scale_fill_manual(values = c(
    "Ubiquitous_RETSI" = "#a4ac86",
    "Ubiquitous_GETSI" = "#919b74",
    "Tissue-specific_RETSI" = "#D2B48C",
    "Tissue-specific_GETSI" = "#c8a77b"
  )) +
  labs(x = "SPICEY measure") +
  theme_gray() +
  theme(
    legend.position = "none",
    ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 10, margin = margin(t = 5)),
    axis.text = element_text(size = 8, margin = margin(t = 2)),
    strip.text = element_text(size = 8),
    axis.text.x = element_text(angle = 30),
    plot.title = element_text(size = 12)
  ) +
  facet_grid(~ type) +
  ggtitle("Promoter")



enh <- bind_rows(
  # Tissue-specific: match by gene and cell type, keep all rows
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    # filter(direct_TSS == TRUE) %>%
    inner_join(ct_markers %>% dplyr::select(-Source),
               by = c("gene_id" = "Gene", "cell_type" = "CellType")) %>%
    mutate(type = "Tissue-specific") %>%
    filter(gene_id %in% ct_markers$Gene),
  
  # Ubiquitous: just filter by gene list
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    filter(gene_id %in% ubiquitous) %>%
    mutate(type = "Ubiquitous")) %>%
  
  # Factor level for consistency in plotting
  mutate(type = factor(type, levels = c("Ubiquitous", "Tissue-specific")),
         RETSI = as.numeric(RETSI),
         GETSI = as.numeric(GETSI)) %>%
  filter(!is.na(RETSI), !is.na(GETSI), !is.na(type)) %>%
  # mutate(region = paste0(seqnames, ":", start, "-", end)) %>%
  pivot_longer(cols = c(RETSI, GETSI),
               names_to = "spicey_measure",
               values_to = "value") %>% 
  filter(
    spicey_measure != "RETSI" |
    (annotation == "Distal")) %>%
  mutate(
    color_key = paste(type, spicey_measure, sep = "_")
  ) %>%
  ggplot(aes(x = value, color = color_key, fill = color_key)) +
  geom_density(alpha = 0.6) +
  ggside::geom_xsideboxplot(aes(y = spicey_measure, fill = color_key), 
                            orientation = "y", outlier.size = 0.1, 
                            outlier.alpha = 0.5) +
  ggside::scale_xsidey_discrete() +
  scale_y_continuous(name = "Density") +
  scale_color_manual(values = c(
    "Ubiquitous_RETSI" = "#656d4a",
    "Ubiquitous_GETSI" = "#5e614b",
    "Tissue-specific_RETSI" = "#b37a56",
    "Tissue-specific_GETSI" = "#8c5e3c"
  )) +
  scale_fill_manual(values = c(
    "Ubiquitous_RETSI" = "#a4ac86",
    "Ubiquitous_GETSI" = "#919b74",
    "Tissue-specific_RETSI" = "#D2B48C",
    "Tissue-specific_GETSI" = "#c8a77b"
  )) +
  
  labs(x = "SPICEY measure") +
  # ggtitle("Promoter regions") +
  theme_gray() +
  theme(
    legend.position = "none",
    ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 10, margin = margin(t = 5)),  # smaller top margin
    axis.text = element_text(size = 8, margin = margin(t = 2)),   # bring x-ticks closer
    strip.text = element_text(size = 8),
    axis.text.x = element_text(angle=30),
    plot.title = element_text(size = 12)
  ) +
  facet_grid(~ type) +
  ggtitle("Distal")


final <- cowplot::plot_grid(prom, enh,                                  
                            labels = c("B", "C"), 
                            label_size = 12)

ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/SPICEY_MARKERS.png"),
       plot = last_plot(), width = 6, height = 3.5, units = "in", dpi = 300)

```

# Entropy 

```{r entropy, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

# prom -------------------------------------------------------------------------
entropy <- bind_rows(
  # Tissue-specific data
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    dplyr::filter(gene_id %in% ct_markers$Gene) %>%
    mutate(type = "Tissue-specific"),
  
  # Ubiquitous data
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    dplyr::filter(gene_id %in% ubiquitous) %>%
    mutate(type = "Ubiquitous")) %>%
  mutate(type = factor(type, levels = c("Ubiquitous", "Tissue-specific")),
         RETSI = as.numeric(RETSI),
         GETSI = as.numeric(GETSI)) %>%
  filter(
    !is.na(RETSI),
    !is.na(GETSI),
    !is.na(type)) %>%
  {rownames(.) <- NULL; .} %>%
  filter(!is.na(GETSI),
         !is.na(RETSI)) %>%
  pivot_longer(cols = c(RETSI_entropy, GETSI_entropy),
               names_to = "spicey_measure",
               values_to = "value") %>%
  mutate(spicey_measure = gsub("_entropy", "", spicey_measure)) %>%
  filter(
    spicey_measure != "RETSI" |
    (annotation == "Promoter")) %>%
  ggplot(aes(x = type,
             y = value,
             fill = type)) +
  geom_violin() +
  geom_boxplot(alpha = 0.4) +  # Adjust outlier behavior if needed
  theme_gray() +
  labs(x = "", y = "Entropy") +
  theme(
    legend.position = "none",
    ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 10, margin = margin(t = 5)),
    axis.text = element_text(size = 8, margin = margin(t = 2)),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(size = 8),
    plot.title = element_text(size = 12)
  ) +
  scale_fill_manual(values = c(
    "Ubiquitous" = "#919b74",
    "Tissue-specific" = "#c8a77b"
  )) +
  # ylim(c(1,1.2))+
  geom_signif(comparisons = list(
    c("Tissue-specific", "Ubiquitous")),
    y_position = c(1, 1.1),  # Adjust y position for annotations
    map_signif_level = TRUE,  # Display significance level
    textsize = 2.3,
    vjust = 0.01,               # Moves text slightly above the line
    tip_length = 0.02         # Negative value to flip arrows **upwards**
  ) +
  facet_grid(~spicey_measure) 

ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/ENTROPY_PROM_MARKERS.png"),
       plot = entropy, width = 4.5, height = 4, units = "in", dpi = 300)


# all -------------------------------------------------------------------------
entropy_prom <- bind_rows(
  # Tissue-specific data
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    dplyr::filter(TSS_gene %in% ct_markers$Gene) %>%
    mutate(type = "Tissue-specific"),
  
  # Ubiquitous data
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    dplyr::filter(TSS_gene %in% ubiquitous) %>%
    mutate(type = "Ubiquitous")) %>%
  mutate(type = factor(type, levels = c("Ubiquitous", "Tissue-specific")),
         RETSI = as.numeric(RETSI),
         GETSI = as.numeric(GETSI)) %>%
  filter(
    !is.na(RETSI),
    !is.na(GETSI),
    !is.na(type)) %>%
  {rownames(.) <- NULL; .} %>%
  filter(!is.na(GETSI),
         !is.na(RETSI)) %>%
  pivot_longer(cols = c(RETSI_entropy, GETSI_entropy),
               names_to = "spicey_measure",
               values_to = "value") %>%
  mutate(spicey_measure = gsub("_entropy", "", spicey_measure)) %>%
  dplyr::filter(annotation == "Promoter") %>%
  ggplot(aes(x = type,
             y = value,
             fill = type)) +
  geom_violin() +
  geom_boxplot(alpha = 0.4) +  # Adjust outlier behavior if needed
  theme_gray() +
  labs(x = "", y = "Entropy") +
  theme(
    legend.position = "none",
    ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 10, margin = margin(t = 5)),
    axis.text = element_text(size = 8, margin = margin(t = 2)),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(size = 8),
    plot.title = element_text(size = 12)
  ) +
  scale_fill_manual(values = c(
    "Ubiquitous" = "#919b74",
    "Tissue-specific" = "#c8a77b"
  )) +
  # ylim(c(1,1.2))+
  geom_signif(comparisons = list(
    c("Tissue-specific", "Ubiquitous")),
    y_position = c(1, 1.1),  # Adjust y position for annotations
    map_signif_level = TRUE,  # Display significance level
    textsize = 2.3,
    vjust = 0.01,               # Moves text slightly above the line
    tip_length = 0.02         # Negative value to flip arrows **upwards**
  ) +
  facet_grid(~spicey_measure) +
  ggtitle("Promoter")


entropy_distal <- bind_rows(
  # Tissue-specific data
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    dplyr::filter(gene_id %in% ct_markers$Gene) %>%
    mutate(type = "Tissue-specific"),
  
  # Ubiquitous data
  SPICEY_ANNOTATED_COACC$linked %>%
    data.frame() %>%
    dplyr::filter(gene_id %in% ubiquitous) %>%
    mutate(type = "Ubiquitous")) %>%
  mutate(type = factor(type, levels = c("Ubiquitous", "Tissue-specific")),
         RETSI = as.numeric(RETSI),
         GETSI = as.numeric(GETSI)) %>%
  filter(
    !is.na(RETSI),
    !is.na(GETSI),
    !is.na(type)) %>%
  {rownames(.) <- NULL; .} %>%
  filter(!is.na(GETSI),
         !is.na(RETSI)) %>%
  pivot_longer(cols = c(RETSI_entropy, GETSI_entropy),
               names_to = "spicey_measure",
               values_to = "value") %>%
  mutate(spicey_measure = gsub("_entropy", "", spicey_measure)) %>%
  dplyr::filter(annotation == "Distal") %>%
  ggplot(aes(x = type,
             y = value,
             fill = type)) +
  geom_violin() +
  geom_boxplot(alpha = 0.4) +  # Adjust outlier behavior if needed
  theme_gray() +
  labs(x = "", y = "Entropy") +
  theme(
    legend.position = "none",
    ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 10, margin = margin(t = 5)),
    axis.text = element_text(size = 8, margin = margin(t = 2)),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(size = 8),
    plot.title = element_text(size = 12)
  ) +
  scale_fill_manual(values = c(
    "Ubiquitous" = "#919b74",
    "Tissue-specific" = "#c8a77b"
  )) +
  # ylim(c(1,1.2))+
  geom_signif(comparisons = list(
    c("Tissue-specific", "Ubiquitous")),
    y_position = c(1, 1.1),  # Adjust y position for annotations
    map_signif_level = TRUE,  # Display significance level
    textsize = 2.3,
    vjust = 0.01,               # Moves text slightly above the line
    tip_length = 0.02         # Negative value to flip arrows **upwards**
  ) +
  facet_grid(~spicey_measure) +
  ggtitle("Distal")


final_ENT <- cowplot::plot_grid(entropy_prom, entropy_distal,                                  
                                labels = c("A", "B"), 
                                label_size = 12)

ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/ENTROPY_MARKERS.png"),
       plot = final_ENT, width = 5.5, height = 3.5, units = "in", dpi = 300)

```

# Main figure

```{r final-figure, message=FALSE, warning=FALSE}

## Combine plots
# bottom_row <- cowplot::plot_grid(prom, enh,
#                                  labels = c("B", "C"),
#                                  label_size = 12,
#                                  ncol = 2)

# Now combine the top plot (distribution) with the bottom row
final_plot <- cowplot::plot_grid(distribution, final,
                                 final_ENT,
                                 # labels = c("A", "B"),  # "A" label for the top, no label for the combined bottom row
                                 label_size = 12,
                                 nrow = 3,
                                 rel_heights = c(1, 1, 1))  # adjust as needed

ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/FINAL_FIGURE.png"),
       plot = final_plot, width = 5, height = 9, units = "in", dpi = 300)

```

# Heatmap 

```{r spicey-combined-heatmap, message=FALSE, warning=FALSE}

# Step 1: Aggregate RETSI & GETSI at gene + cell_type level
agg_df <- SPICEY_ANNOTATED_COACC %>%
  data.frame() %>%
  # filter(annotation == "Promoter", 
  #        in_TSS == TRUE) %>%
  filter(!is.na(RETSI), 
         !is.na(GETSI), 
         !is.na(gene_id)) %>%
  group_by(gene_id, cell_type) %>%
  summarise(
    RETSI = mean(RETSI, na.rm = TRUE),
    GETSI = mean(GETSI, na.rm = TRUE),
    combined_mean = (RETSI + GETSI)/2,
    .groups = "drop"
  ) %>%
  ungroup()
  

# Step 2: Select top genes per cell type based on combined_mean
selected_genes <- agg_df %>%
  group_by(cell_type) %>%
  slice_max(order_by = combined_mean, n = 5, with_ties = FALSE) %>%
  pull(gene_id) %>%
  unique()

# Step 3: Filter aggregated df to selected genes only
filtered_df <- agg_df %>%
  filter(gene_id %in% selected_genes)

# Step 4: Pivot to wide matrix for sorting
wide_mat <- filtered_df %>%
  dplyr::select(gene_id, cell_type, combined_mean) %>%
  pivot_wider(names_from = cell_type, values_from = combined_mean) %>%
  column_to_rownames("gene_id") %>%
  as.matrix()
  
wide_mat[is.na(wide_mat)] <- 0
celltypes <- colnames(wide_mat)

# Step 5: For each gene find cell type of max combined_mean
max_ct_per_gene <- apply(wide_mat, 1, function(x) celltypes[which.max(x)])

# Step 6: Order genes so their max cell types follow cell type order (start with current order)
# This groups genes by their max cell type
gene_order_df <- data.frame(
  gene = rownames(wide_mat),
  max_cell_type = max_ct_per_gene,
  stringsAsFactors = FALSE
) %>%
  arrange(factor(max_cell_type, levels = celltypes))

ordered_genes <- gene_order_df$gene

# Step 7: Order cell types by the first occurrence of their genes in the ordered genes list
# This reorders cell types so they align with gene grouping
celltype_order_df <- gene_order_df %>%
  group_by(max_cell_type) %>%
  summarise(first_gene_pos = min(match(gene, ordered_genes))) %>%
  arrange(first_gene_pos)

ordered_celltypes <- celltype_order_df$max_cell_type

# Step 8: Set factors in filtered_df to ordered levels for plotting
plot_df <- filtered_df %>%
  mutate(
    gene_id = factor(gene_id, levels = ordered_genes),
    cell_type = factor(cell_type, levels = ordered_celltypes)
  )
  
# Step 9: Plot heatmap
gene_colors <- ifelse(levels(plot_df$gene_id) %in% ct_markers$Gene, "#965819", "grey30")

# Plot heatmap with colored row text
custom_colors <- c(
  "white",
  # "#F8E3E0", 
  "#E18C80", #"#CA6D5F", 
  "#B86357", #"#84473E", 
  "#723D36", #"#60342D", 
  "#4F2A25" #"#3D211D"
)

ggplot(plot_df %>% data.frame(), 
       aes(x = cell_type, y = gene_id, fill = combined_mean)) +
  geom_tile(color = "grey80", width = 0.95) +  # width closer to 1 to fill gaps
  scale_x_discrete(expand = c(0, 0)) +        # remove padding on x-axis
  scale_y_discrete(expand = c(0, 0)) +        # remove padding on y-axis
  coord_fixed(ratio = 0.5) +                   # fix aspect ratio to reduce horizontal space (try 0.5, tweak as needed)
  scale_fill_gradientn(
    colours = custom_colors,
    limits = c(0, 1),
    name = paste0("x SPICEY"),
    na.value = "grey90") +
  theme_gray() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
    axis.text.y = element_text(size = 12, color = gene_colors),
    panel.grid = element_blank(),
    ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 10, margin = margin(t = 5)),
    axis.text = element_text(size = 8, margin = margin(t = 2)),
    strip.text = element_text(size = 8),
    plot.title = element_text(size = 12)) +
  labs(
    x = "Cell Type",
    y = "Gene")


ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/SPICEY_heatmap.png"),
       plot = spicey_heatmap, width = 8.5, height = 6.5, units = "in", dpi = 300)

```

```{r main-heatmap, message=FALSE, warning=FALSE}

# Step 1: Compute combined z-scores and select top genes per cell type
top_retsi <- SPICEY_ANNOTATED_COACC %>%
  data.frame() %>%
  filter(!is.na(RETSI), 
         !is.na(GETSI), 
         !is.na(gene_id) 
         # in_TSS == TRUE, 
         # annotation == "Promoter"
         ) %>%
  mutate(GETSI_z = scale(GETSI)[, 1],
         RETSI_z = scale(RETSI)[, 1],
         combined_score = (RETSI_z + GETSI_z) / 2) %>%
  group_by(cell_type) %>%
  arrange(desc(combined_score)) %>%
  distinct(cell_type, gene_id, .keep_all = TRUE) %>%
  slice_head(n = 10) %>%
  ungroup()

# Step 2: Get the unique genes selected
selected_genes <- unique(top_retsi$gene_id)

# Step 3: Create long-format data for selected genes across all cell types
heatmap_df <- SPICEY_ANNOTATED_COACC %>%
  data.frame() %>%
  # filter(in_TSS == TRUE, 
  #         annotation == "Promoter") %>%
  filter(gene_id %in% selected_genes) %>%
  filter(!is.na(RETSI), !is.na(GETSI)) %>%
  mutate(
    GETSI_z = scale(GETSI)[, 1],
    RETSI_z = scale(RETSI)[, 1],
    combined_score = (RETSI_z + GETSI_z) / 2
  ) %>%
  dplyr::select(gene_id, cell_type, combined_score) %>%
  group_by(gene_id, cell_type) %>%
  summarise(combined_score = mean(combined_score), .groups = "drop")

# Step 4: Order genes by their max cell type for better row sorting
wide_mat <- heatmap_df %>%
  pivot_wider(names_from = cell_type, values_from = combined_score, values_fill = 0) %>%
  column_to_rownames("gene_id") %>%
  as.matrix()

gene_order_df <- data.frame(
  gene_id = rownames(wide_mat),
  max_cell_type = colnames(wide_mat)[apply(wide_mat, 1, which.max)],
  max_score = apply(wide_mat, 1, max)
) %>%
  arrange(max_cell_type, desc(max_score))

ordered_genes <- gene_order_df$gene_id

# Step 5: Plot heatmap
heatmap_df$gene_id <- factor(heatmap_df$gene_id, levels = ordered_genes)

gene_colors <- ifelse(levels(heatmap_df$gene_id) %in% 
                        ct_markers$Gene, "#965819", "grey30")
custom_colors <- c(
  "white",
  # "#F8E3E0", 
  "#E18C80", #"#CA6D5F", 
  "#B86357", #"#84473E", 
  "#723D36", #"#60342D", 
  "#4F2A25" #"#3D211D"
)


ggplot(heatmap_df, aes(x = cell_type, y = gene_id, fill = combined_score)) +
  geom_tile(color = "grey80", width = 0.95) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  coord_fixed(ratio = 0.5) +
  scale_fill_gradientn(
    colours = custom_colors,
    # limits = c(0, 1),
    name = paste0("SPICEY \nz-score"),
    na.value = "grey90") +
  theme_gray() +
  guides(fill = guide_colourbar(barwidth = 0.5, barheight = 4)) +  # Smaller legend bar
  theme(
    legend.title=element_text(size=7),
    legend.text = element_text(size=7),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 7),
    axis.text.y = element_text(size = 7, color = gene_colors),
    panel.grid = element_blank(),
    # ggside.panel.scale.x = 0.3,
    axis.title = element_text(size = 7),
    axis.text = element_text(size = 7),
    strip.text = element_text(size = 7),
    plot.title = element_text(size = 7)) +
  labs(
    x = "Cell type",
    y = "Gene")

ggsave(paste0(here::here("/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs"), "/SPICEY_heatmap.png"),
       plot = last_plot(), width = 3, height = 7, units = "in", dpi = 300)

```

```{r function-heatmap, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

make_spicey_heatmap <- function(spicey_df, metric = c("RETSI_z", "GETSI_z", "combined"), 
                                marker_genes = NULL, output_path = NULL) {
  metric <- match.arg(metric)
  
  # Step 1: Normalize and compute z-scores
  spicey_z <- spicey_df %>%
    data.frame() %>%
    filter(!is.na(RETSI), !is.na(GETSI), !is.na(gene_id)) %>%
    mutate(
      GETSI_z = scale(GETSI)[, 1],
      RETSI_z = scale(RETSI)[, 1],
      combined = (RETSI_z + GETSI_z) / 2
    )
  
  # Step 2: Select top genes per cell type by chosen metric
  top_genes <- spicey_z %>%
    group_by(cell_type) %>%
    arrange(desc(.data[[metric]])) %>%
    distinct(cell_type, gene_id, .keep_all = TRUE) %>%
    slice_head(n = 10) %>%
    ungroup()
  
  selected_genes <- unique(top_genes$gene_id)
  
  # Step 3: Build heatmap matrix
  heatmap_df <- spicey_z %>%
    filter(gene_id %in% selected_genes) %>%
    group_by(gene_id, cell_type) %>%
    summarise(z_score = mean(.data[[metric]], na.rm = TRUE), .groups = "drop")
  
  # Step 4: Order rows by max cell-type score
  wide_mat <- heatmap_df %>%
    pivot_wider(names_from = cell_type, values_from = z_score, values_fill = 0) %>%
    column_to_rownames("gene_id") %>%
    as.matrix()
  
  gene_order_df <- data.frame(
    gene_id = rownames(wide_mat),
    max_cell_type = colnames(wide_mat)[apply(wide_mat, 1, which.max)],
    max_score = apply(wide_mat, 1, max)
  ) %>%
    arrange(max_cell_type, desc(max_score))
  
  ordered_genes <- gene_order_df$gene_id
  heatmap_df$gene_id <- factor(heatmap_df$gene_id, levels = ordered_genes)
  
  # Step 5: Define gene label colors
  gene_colors <- rep("grey30", length(ordered_genes))
  names(gene_colors) <- ordered_genes
  if (!is.null(marker_genes)) {
    gene_colors[names(gene_colors) %in% marker_genes] <- "#965819"
  }
  
  # Step 6: Plot
  p <- ggplot(heatmap_df, aes(x = cell_type, y = gene_id, fill = z_score)) +
    geom_tile(color = "grey80", width = 0.95) +
    scale_x_discrete(expand = c(0, 0)) +
    scale_y_discrete(expand = c(0, 0)) +
    coord_fixed(ratio = 0.5) +
    scale_fill_gradientn(
      colours = c("white", "#E18C80", "#B86357", "#723D36", "#4F2A25"),
      na.value = "grey90",
      name = paste0(metric, "\nscore")
    ) +
    theme_minimal(base_size = 8) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10, color = gene_colors[levels(heatmap_df$gene_id)]),
      panel.grid = element_blank(),
      axis.title = element_text(size = 8),
      plot.title = element_text(size = 10)
    ) +
    labs(x = "Cell type", y = "Gene")
  
  # Save if path provided
  if (!is.null(output_path)) {
    ggsave(output_path, plot = p, width = 3, height = 7.5, units = "in", dpi = 300)
  }
  
  return(p)
}


# Plot RETSI_z
make_spicey_heatmap(SPICEY_ANNOTATED_COACC, metric = "RETSI_z", 
                    marker_genes = ct_markers$Gene,
                    output_path = "/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs/zRETSI_heatmap.png")

# Plot GETSI_z
make_spicey_heatmap(SPICEY_ANNOTATED_COACC, metric = "GETSI_z", 
                    marker_genes = ct_markers$Gene,
                    output_path = "/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs/zGETSI_heatmap.png")

# Plot combined z-score
make_spicey_heatmap(SPICEY_ANNOTATED_COACC, metric = "combined", 
                    marker_genes = ct_markers$Gene,
                    output_path = "/homes/users/gfuentes/scratch/projects/spicey_paper/HPAP_CTRL/figs/zSPICEY_heatmap.png")


```

## Computing GETSI

To calculate the **Gene Expression Tissue Specificity Index (GETSI)**, the following inputs are required:

-   **`rna`**: A named list of `GRanges` objects or `data.frame`s (convertible to `GRanges`), each containing differential gene expression results for a specific cell type.
-   **`gene_id`**: A character string specifying the column name with gene identifiers (e.g., official gene symbols).

SPICEY outputs a `data.frame` that integrates the input differential expression data with computed GETSI scores for each gene.

**Note:** Verify that your inputs adhere to the format described in the *Input Requirements* section before execution.

```{r getsi, message=FALSE, warning=FALSE}
getsi <- SPICEY(rna=rna, gene_id = "gene_id")
head(getsi)
```

## Computing SPICEY

SPICEY offers an integrated approach to quantify tissue specificity at both the epigenetic and transcriptional levels by simultaneously computing Regulatory Element Tissue Specificity Indices (RETSI) and Gene Expression Tissue Specificity Indices (GETSI) from single-cell data.

By supplying both `atac` and `rna` inputs together to the `SPICEY()` function, the tool calculates RETSI and GETSI scores and returns a list with each specificity measure provided separately.

```{r spicey, message=FALSE, warning=FALSE}
spicey <- SPICEY(atac=atac, 
                region_id = "region_id", 
                rna=rna,
                gene_id = "gene_id")
lapply(spicey, head)
```

## Building Tissue-Specific Regulatory Networks

SPICEY facilitates the construction of tissue-specific regulatory networks by integrating RETSI and GETSI scores through the association of regulatory elements with their putative target genes. This linkage connects each regulatory region’s cell type-specific RETSI score to the corresponding gene’s GETSI score, enabling comprehensive downstream network analyses.

To establish these links, regulatory regions must be annotated to target genes. SPICEY supports two annotation strategies:

1.  **Proximity-based annotation** — assigning regions to the nearest transcription start site (TSS).\
2.  **Co-accessibility-based annotation** — leveraging promoter–enhancer co-accessibility relationships derived from snATAC-seq data (e.g., via `Cicero`).

### Annotating Regions to Putative Target Genes (Optional)

#### Nearest Gene Annotation

This method links each regulatory region to its closest gene TSS.

##### Required inputs:

-   `peaks`: A `GRanges` object or `data.frame` containing peaks to annotate, including these columns:
    -   `seqnames`: Chromosome name (e.g., chr1)
    -   `start`: Peak start coordinate
    -   `end`: Peak end coordinate
    -   `region_id`: Unique region identifier in genomic coordinate format (e.g., `chr1-5000-5800` or `chr1:5000-5800`)
-   `txdb`: A `TxDb` object for genome annotation (e.g., `TxDb.Hsapiens.UCSC.hg38.knownGene`).
-   `annot_dbi`: An `AnnotationDbi` object for gene metadata (e.g., `org.Hs.eg.db`).
-   `upstream`: Number of bases upstream from the TSS to consider (default: 2000).
-   `downstream`: Number of bases downstream from the TSS to consider (default: 2000).

##### Optional parameters:

-   `protein_coding_only`: Limit annotations to protein-coding genes (default: `TRUE`).
-   `add_tss_annotation`: Annotate regulatory elements overlapping the TSS (default: `FALSE`). If enabled, uses ±1 bp around TSS instead of ±2000 bp.
-   `verbose`: Display progress messages (default: `TRUE`).

```{r re-gene-nearest, message=FALSE, warning=FALSE}

peaks <- SPICEY:::.parse_input_diff(atac)
peaks <- peaks %>% tidyr::separate(
  region_id,
  into = c("chr", "start", "end"), sep = "-",
  convert = TRUE,remove = FALSE) %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE)

annotation_near <- annotate_with_nearest(
  peaks = peaks,
  txdb = TxDb.Hsapiens.UCSC.hg38.knownGene,
  annot_dbi = org.Hs.eg.db,
  protein_coding_only = TRUE,
  verbose = TRUE,
  add_tss_annotation = FALSE,
  upstream = 2000,
  downstream = 2000)

head(annotation_near)
```

This function returns a data frame linking each regulatory region to its nearest gene based on genomic proximity.

#### Annotate to co-accessible Genes

This method connects regulatory regions to genes through co-accessibility interactions, which must be computed externally (e.g., using **Cicero**).

##### Required inputs:

-   `peaks`: A `GRanges` object or `data.frame` of peaks to annotate, including the following columns:
    -   `seqnames`: Chromosome name (e.g., chr1)
    -   `start`: Peak start coordinate
    -   `end`: Peak end coordinate
    -   `region_id`: Unique region identifier in genomic coordinate format (e.g., `chr1-5000-5800` or `chr1:5000-5800`)
-   `txdb`: A `TxDb` object for genome annotation (e.g., `TxDb.Hsapiens.UCSC.hg38.knownGene`).
-   `annot_dbi`: An `AnnotationDbi` object for gene metadata (e.g., `org.Hs.eg.db`).
-   `links_df`: A `data.frame` containing co-accessibility links or scores (e.g., from Cicero), with these required columns:
    -   `Peaks1`: Genomic coordinate or ID of the first peak in the pair
    -   `Peaks2`: Genomic coordinate or ID of the second peak linked by co-accessibility
    -   `coaccess`: Co-accessibility score or correlation value between peaks
-   `upstream`: Number of bases upstream from the TSS to consider (default: 2000).
-   `downstream`: Number of bases downstream from the TSS to consider (default: 2000).

##### Optional parameters:

-   `protein_coding_only`: Limit annotations to protein-coding genes (default: `TRUE`).
-   `add_tss_annotation`: Annotate regulatory elements overlapping the TSS (default: `FALSE`). If enabled, uses ±1 bp around TSS instead of ±2000 bp.
-   `verbose`: Display progress messages (default: `TRUE`).

```{r re-gene-coaccessibility, message=FALSE, warning=FALSE}

peaks <- SPICEY:::.parse_input_diff(atac)
peaks <- peaks %>% 
  tidyr::separate(
    region_id,
    into = c("chr", "start", "end"), sep = "-",
    convert = TRUE,remove = FALSE) %>%
  GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE)

annotation_coacc <- annotate_with_coaccessibility(
  peaks = peaks,
  txdb = TxDb.Hsapiens.UCSC.hg38.knownGene,
  links_df=cicero_links,
  annot_dbi = org.Hs.eg.db,
  protein_coding_only = TRUE,
  verbose = TRUE,
  add_tss_annotation = FALSE,
  upstream = 2000,
  downstream = 2000)

head(annotation_coacc)
```

This function returns a data frame linking each regulatory region to its associated gene based on co-accessibility relationships.

#### Annotate to both

Alternatively, users may wish to annotate regulatory regions using both proximity to transcription start sites (TSS) and co-accessibility information simultaneously. To accommodate this, one can use SPICEY functionalists to generate a merged annotation object, combining both distance-based and co-accessibility-based annotations for each region in a unified framework:

```{r re-gene-near-coacc-merged, message=FALSE, warning=FALSE}

annotation_merged <- annotate_with_coaccessibility(
  peaks = annotation_near |> 
    dplyr::rename(nearestGeneSymbol = gene_id) |>
    makeGRangesFromDataFrame(keep.extra.columns = T),
  txdb = TxDb.Hsapiens.UCSC.hg38.knownGene,
  links_df=cicero_links,
  annot_dbi = org.Hs.eg.db,
  protein_coding_only = TRUE,
  verbose = TRUE,
  add_tss_annotation = FALSE,
  upstream = 2000,
  downstream = 2000)

head(annotation_merged)
```

In this way, each regulatory region is annotated with two complementary layers of information:

-   **Nearest-gene annotation**, which includes:

1.  `distanceToTSS`: the distance from the region to the nearest transcription start site (TSS),
2.  `nearestGeneSymbol`: the gene symbol of the closest gene,
3.  `annotation`: the genomic context of the region (e.g., Promoter or Distal based on proximity to the TSS).

-   **Co-accessibility-based annotation**, where the region is linked to its co-accessible gene (`gene_id`), as determined by Cicero-derived chromatin interaction networks (see relevant section for details).

This merged approach provides a more comprehensive regulatory landscape by integrating both spatial proximity and functional chromatin interaction data.

#### Using custom region-to-gene annotation

The annotation step(s) are **optional**. Users can either generate these annotations using SPICEY’s built-in functions or supply a pre-computed `data.frame` of gene–region associations. When using pre-computed data to construct tissue-specific regulatory networks, the `data.frame` must include at minimum the following columns:

-   `region_id`: Unique identifier for each region, following standard genomic coordinate formats such as *chr-start-end* (e.g., `chr1-5000-5800`) or *chr:start-end* (e.g., `chr1:5000-5800`).
-   `gene_id`: Unique gene identifier using *official gene symbols* (e.g., `GAPDH`).
-   `cell_type`: Cell type or cluster label.

### Integrating SPICEY measures to build tissue-specific networks

With the annotation linking regulatory elements to their target genes (via TSS proximity or co-accessibility), SPICEY enables integration of RETSI and GETSI scores. This links each regulatory region’s cell type-specific RETSI score with its target gene’s corresponding GETSI score, facilitating the construction of detailed tissue-specific regulatory networks.

This approach supports comprehensive analysis of regulatory mechanisms at both epigenetic and transcriptional levels.

```{r spicey_link_annot, message=FALSE, warning=FALSE}

# Using nearest gene annotation data 
spicey_near <- SPICEY(rna = rna,
                      gene_id = "gene_id",
                      atac=atac,
                      region_id="region_id",
                      annotation = annotation_near)


# Using co-accessibility gene annotation data 
spicey_coacc <- SPICEY(rna = rna,
                       gene_id = "gene_id",
                       atac=atac,
                       region_id="region_id",
                       annotation = annotation_coacc)

# Using both annotation data 
spicey_both <- SPICEY(rna = rna,
                      gene_id = "gene_id",
                      atac=atac,
                      region_id="region_id",
                      annotation = annotation_merged)

```

This function returns a list containing separately computed RETSI and GETSI scores, along with an additional element that links these measures based on the selected region-to-gene annotation method.

# Summary

SPICEY offers a comprehensive main function, `SPICEY()`, which streamlines the entire workflow into a single, reproducible process. It also includes optional helper functions for region-to-gene annotation using different strategies: `annotate_with_coaccessibility()` and `annotate_with_nearest()`.

When supplied with differential chromatin accessibility (ATAC) and/or gene expression (RNA) data from single-cell experiments, along with a chosen region-to-gene mapping method ("nearest" or "coaccessibility"), the `SPICEY()` function performs the following:

1.  Computes tissue specificity scores from single-cell data:
    -   RETSI (Regulatory Element Tissue Specificity Index) for ATAC data
    -   GETSI (Gene Expression Tissue Specificity Index) for RNA data
2.  (**Optional**) Annotates regulatory elements to target genes using either:
    -   Nearest gene transcription start site (TSS) (e.g., +/- 2000bp around the TSS)
    -   Co-accessibility links (e.g., derived from Cicero)
3.  Builds tissue-specific regulatory networks by integrating RETSI and GETSI scores via the provided region-to-gene annotation.

The output is a structured list containing all intermediate and final results, facilitating downstream analysis and reuse.

# Output Description

The primary output is a `data.frame` or a list of `data.frames` representing genomic regions (e.g., enhancers or promoters), each annotated with rich metadata derived from chromatin accessibility and gene expression data. Key columns include:

### SPICEY Measures

| Column | Description |
|---------------|---------------------------------------------------------|
| `cell_type` | Cell type exhibiting significant accessibility or expression (e.g., `"Acinar"`). |
| `p_val_adj` | Adjusted p-value from differential testing, controlling for multiple comparisons. |
| `avg_log2FC` | Average log2 fold-change of accessibility/expression in the specified cell type vs others. |
| `region_id` | Genomic interval identifier (e.g., `"chr7:142748901-142749963"`). |
| `RETSI` | Regulatory Element Tissue Specificity Index; values near 1 indicate high cell-type specificity. |
| `RETSI_entropy` | Entropy-based specificity metric; lower values indicate greater cell-type specificity. |
| `gene_id` or `nearestGeneSymbol` | Gene identifier (official gene symbol). |
| `GETSI` | Gene Expression Tissue Specificity Index for linked genes, indicating expression specificity. |
| `GETSI_entropy` | Entropy-based specificity metric for gene expression, analogous to `RETSI_entropy`. |

### Linked SPICEY Measures

| Column | Description |
|---------------|---------------------------------------------------------|
| `cell_type` | Cell type showing significant accessibility (e.g., `"Acinar"`). |
| `p_val_adj_ATAC` | Adjusted p-value from differential accessibility testing. |
| `avg_log2FC_ATAC` | Average log2 fold-change in accessibility for the cell type versus others. |
| `region_id` | Genomic interval identifier (e.g., `"chr7:142748901-142749963"`). |
| `RETSI` | Regulatory Element Tissue Specificity Index. |
| `RETSI_entropy` | Entropy-based specificity measure for accessibility. |
| `gene_id` or `nearestGeneSymbol` | Gene identifier (official gene symbol). |
| `p_val_adj_RNA` | Adjusted p-value from differential expression testing. |
| `avg_log2FC_RNA` | Average log2 fold-change in gene expression for the cell type versus others. |
| `pct.1` | Percentage of cells expressing the gene in the first group of the differential analysis. |
| `pct.2` | Percentage of cells expressing the gene in the second group. |
| `GETSI` | Gene Expression Tissue Specificity Index for linked genes. |
| `GETSI_entropy` | Entropy-based specificity metric for gene expression. |

This annotated `data.frame` serves as a comprehensive resource combining genomic coordinates, cell type-specific regulatory activity, gene associations, and expression specificity—enabling advanced functional genomics analyses.

# Visualization example

```{r plot}

```

# References

# SessionInfo

```{r sessionInfo}

sessionInfo()

```
